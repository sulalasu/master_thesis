#%%
#Load packages
import pandas as pd
import numpy as np
import sys
from pathlib import Path

import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
import statsmodels

import statsmodels.api as sm
from scipy.stats import pearsonr

import holidays


#%%---------------------------------------
# Set vars & load data

# Load Data
df_original = pd.read_csv("../data/03_transformed/output_transformed.csv")
df_original = df_original.set_index("date")
df_original.index = pd.to_datetime(df_original.index)
#%%
# Add additional temporal features (workday, holiday, day of year, day of week)

#Add workday info

vie_holidays = holidays.country_holidays('Austria', subdiv='W')


df_original["is_workday"] = df_original.index.to_series().apply(lambda x: vie_holidays.is_working_day(x))
#df_original = df_original.diff().dropna()
df_original["workday_enc"] = df_original["is_workday"].astype(int)
#alternative ways
#df_original["workday"] = df_original.where(df_original["is_workday"], 1, 0) 
#df_original["workday"] = df_original.apply(lambda workday: 1 if workday else 0)

#holiday encoding:
df_original["holiday"] = pd.Series(df_original.index).apply(lambda x: vie_holidays.get(x)).values
unique_holidays = df_original["holiday"].dropna().unique()
holiday_map = pd.DataFrame({
    "holiday" : unique_holidays,
    "holiday_enc" : range(1, len(unique_holidays)+1)
})
holiday_map = pd.concat([
    pd.DataFrame({"holiday": [np.nan], "holiday_enc": [0]}), 
    holiday_map],
    ignore_index=True
)
df_original = pd.merge(df_original.reset_index(), holiday_map, how="left", on="holiday").set_index("date")

#Add day of the week, day of the year, year columns
df_original["day_of_week"] = df_original.index.dayofweek
df_original["day_of_year"] = df_original.index.dayofyear
df_original["year"] = df_original.index.year


#%%
# Subset data
START_DATE = "2010-05-01"
END_DATE = "2015-05-01"
df = df_original[START_DATE:END_DATE]

#%% 
# set variables
data_x_col = "count"
data_y_list = ["tlmin", "count", "tlmax", "new_cases_daily", "new_cases_weekly", "workday_enc", "holiday_enc", "day_of_week", "day_of_year", "year"]
max_lag = 366

#%%---------------------------------------
# Plot original time series:
fig = plt.figure(figsize = (8,6))
plt.tight_layout()
sns.lineplot(data = df, x=df.index, y="count", linewidth=0.5)
for col in data_y_list:
    sns.lineplot(data = df, x=df.index, y=col, linewidth=0.5, label=col)
plt.legend()
plt.title("count vs tlmin")
plt.xlabel("Date")
plt.show()





#%%---------------------------------------

#Implement lagged cross correlation


def lagged_cross_correlation(data_x, data_y, lag=0):
    """Calculates the lagged cross correlation of data_x and data_y, where both
    of them are serial data (time series in this case).
    data_x is stationary while data_y gets shifted backwards by 'lag' steps.
    To make sure, there is overlapping data, stationary data_x will be 
    cut off by 'lag' data points at the end (because data_y shifts to the "front"/backwards)
    and data_y will only start  at 'lag' steps/data points, because when shifting backwards,
    theres no data there.

    Args:
        data_x (_type_): Stationary serial data
        data_y (_type_): Serial data which will be shifted backwards (if lag is positive)
        lag (int, optional): How many data points to shift data_y (backwards if positive). Defaults to 0.

    Returns:
        Float: Value of pearsonr scipy function, lagged by 'lag' steps.
    """
    if lag != 0:
        x = data_x[:-abs(lag)]
        y = data_y.shift(-lag)[:-abs(lag)]
    elif lag == 0:
        x = data_x
        y = data_y

    lcc_scipy, _ = pearsonr(x, y)            

    return lcc_scipy




#%%---------------------------------------
# Test + Plot lagged cross correlation


#Running for multiple columns:
all_results = []

#better use a df
lcc_results_df = pd.DataFrame()
lcc_results_dict = {}

# fig, ax = plt.subplots()
# ax.plot(df[data_x_col].index, df[data_x_col], linewidth=0.5)


# ax[0] = plt.plot(x, y)
# fig.show()
for exog in data_y_list:
    #print(exog)
    col_data = {}
    metadata = {exog : []}
    for lag in range(0, max_lag):
        #print("lag: ", lag)
        res = lagged_cross_correlation(data_x=df[data_x_col], data_y=df[exog], lag=lag)
        # ax.plot(df.shift(lag).index, df[exog].shift(lag), linewidth=0.5)
        col_data[lag] = res
        metadata[exog].append({"lag":lag, "result_variable":res}) 

    lcc_results_dict[exog] = col_data
    all_results.append(metadata)

lcc_results_df = (pd.DataFrame(lcc_results_dict)
                  .reset_index().
                  rename(columns={"index":"lag"})
)
print(lcc_results_df)
    
# fig.show()

#%% 
# plotting
fig, ax = plt.subplots()
# ax.plot(lcc_results_df["lag"], lcc_results_df["tlmin"])
for col in lcc_results_df:
    if col != "lag":
        ax.plot(lcc_results_df["lag"], lcc_results_df[col], label=col)
plt.legend()
plt.show()

# %%
# Scatter plot (raw data -- not lagged)

df.index = pd.to_datetime(df.index)
df["day_of_year"] = df.index.dayofyear
fig, axs = plt.subplots(nrows=len(data_y_list), figsize=(8, 32))
# ax.plot(lcc_results_df["lag"], lcc_results_df["tlmin"])
for i, col in enumerate(data_y_list):
    axs[i].scatter(x=df[data_x_col], y=df[col], c=df["day_of_year"], label=col, s=10, alpha=0.7)
    axs[i].title.set_text(col)
plt.legend()
plt.show()

# %%
